#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""
 (c) 2022 - Copyright CTyunOS Inc

 Authors:
   youyifeng <youyf2@chinatelecom.cn>

"""
import logging
import os
import argparse
import json
import datetime
import sys
from optparse import OptionParser, SUPPRESS_HELP

import cve_ease as ease
from cve_ease import read_config

from cve_ease.commands import *

VERSION = '0.0.4'
RELEASE = '1'


def get_options():
    """process options from command line and config file"""
    common_commands = ['help', 'cve', 'sa']
    usage = "%%prog [global-options] command [command-options-and-arguments]\n\n" \
            "Common commands: %s" % ', '.join(sorted(common_commands))
    parser = OptionParser(usage=usage)
    parser.disable_interspersed_args()

    parser.add_option("-c", "--config", dest="configfile",
                      help="load config file from path",
                      default="/etc/cve-ease/cve-ease.cfg",
                      metavar="FILE")
    parser.add_option("-q", "--quiet",
                      action="store_false", dest="verbose", default=True,
                      help="don't print status messages to stdout")
    parser.add_option("-d", "--debug",
                      action="store_false", dest="debug", default=False,
                      help="run in debug mode")

    (options, args) = parser.parse_args()

    parser.print_help()
    parser.print_usage()
    parser.print_version()

    print((options, args))
    try:
        global_config = read_config(configfile=options.configfile)
    except ease.ConfigurationError as e:
        parser.error(e.args[0])
        assert False  # pragma: no cover
    options.config = global_config
    print("options configfile:", options.configfile)
    # print(dir(options))
    # for ss in options.config.sections():
    #     for opt in options.config[ss]:
    #         print(ss, opt, options.config[ss][opt])

    # print(ease.Config)
    ease.print_config()
    # # update options according to local config
    # for name, value in six.iteritems(result):
    #     if getattr(options, name, None) is None:
    #         setattr(options, name, value)
    #

    if not args:
        options.help_commands = True
    if options.help_commands:
        # hijack args to [return_code, message]
        return options, '_list_commands', [0, '']

    aliases = {
        'cancel-task': 'cancel',
        'cxl': 'cancel',
        'list-commands': 'help',
        'move-pkg': 'move-build',
        'move': 'move-build',
        'latest-pkg': 'latest-build',
        'tag-pkg': 'tag-build',
        'tag': 'tag-build',
        'untag-pkg': 'untag-build',
        'untag': 'untag-build',
        'watch-tasks': 'watch-task',
    }
    cmd = args[0]
    cmd = aliases.get(cmd, cmd)
    # if cmd.lower() in greetings:
    #     cmd = "moshimoshi"
    cmd = cmd.replace('-', '_')
    if ('anon_handle_' + cmd) in globals():
        if not options.force_auth and '--mine' not in args:
            options.noauth = True
        cmd = 'anon_handle_' + cmd
    elif ('handle_' + cmd) in globals():
        cmd = 'handle_' + cmd
    else:
        # hijack args to [return_code, message]
        return options, '_list_commands', [1, 'Unknown command: %s' % args[0]]

    return options, cmd, args[1:]


def handle_help(options, args):
    "[info] List available commands"
    usage = "usage: %prog help <category> ..."
    usage += "\n(Specify the --help global option for a list of other help options)"
    parser = OptionParser(usage=usage)
    # the --admin opt is for backwards compatibility. It is equivalent to: koji help admin
    parser.add_option("--admin", action="store_true", help=SUPPRESS_HELP)

    (options, args) = parser.parse_args(args)

    # chosen = set(args)
    # if options.admin:
    #     chosen.add('admin')
    # avail = set(list(categories.keys()) + ['all'])
    # unavail = chosen - avail
    # for arg in unavail:
    #     print("No such help category: %s" % arg)
    #
    # if not chosen:
    #     list_commands()
    # else:
    #     list_commands(chosen)


if __name__ == "__main__":
    # 加载配置
    global options
    options, command, args = get_options()

    exit(1)

    rv = 0
    try:
        rv = locals()[command].__call__(options, args)
        if not rv:
            rv = 0
    except KeyboardInterrupt:
        rv = 1
    except SystemExit:
        raise
    except Exception:
        if options.debug:
            raise
        else:
            exctype, value = sys.exc_info()[:2]
            rv = 1
            # logger.error("%s: %s" % (exctype.__name__, value))

    sys.exit(rv)
