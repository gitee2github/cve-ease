# -*- coding: utf-8 -*-

"""
 (c) 2023 - Copyright CTyunOS Inc

 Authors:
   youyifeng <youyf2@chinatelecom.cn>

"""

import datetime
import os

import requests
import json
from cve_ease_dev.models import CVRFXML


class Scraper:
    def __init__(self):
        pass

    def prune_sql_table(self):
        pass

    def scrapyCVE(self):
        """
        :API: https://gitee.com/openeuler/website-v2/blob/master/web-ui/docs/.vuepress/api/security.js
        :return: json

{
    "code": 0,
    "msg": "",
    "result": {
        "totalCount": 5329,
        "securityNoticeList": [],
        "cveDatabaseList": [
            {
                "id": 22370,
                "affectedProduct": "",
                "announcementTime": "",
                "attackComplexityNVD": "",
                "attackComplexityOE": "",
                "attackVectorNVD": "",
                "attackVectorOE": "",
                "availabilityNVD": "",
                "availabilityOE": "",
                "confidentialityNVD": "",
                "confidentialityOE": "",
                "cveId": "CVE-2023-26081",
                "cvsssCoreNVD": "7.5",
                "cvsssCoreOE": "7.5",
                "integrityNVD": "",
                "integrityOE": "",
                "nationalCyberAwarenessSystem": "",
                "packageName": "epiphany",
                "privilegesRequiredNVD": "",
                "privilegesRequiredOE": "",
                "scopeNVD": "",
                "scopeOE": "",
                "status": "Unaffected",
                "summary": "In Epiphany (aka GNOME Web) through 43.0, untrusted web content can trick users into exfiltrating passwords, because autofill occurs in sandboxed contexts.",
                "type": "",
                "userInteractionNVD": "",
                "userInteractionOE": "",
                "updateTime": "2023-03-03 11:01:01",
                "createTime": "2023-03-03 11:01:01",
                "securityNoticeNo": "",
                "parserBean": null,
                "cvrf": null,
                "packageList": null
            },
            {},
            ...,
            {}
        ]
    }
}

        """
        api_url = 'https://www.openeuler.org/api-cve/cve-security-notice-server/cvedatabase/findAll'
        body = {"keyword": "", "status": "", "pages": {"page": 1, "size": 1000000}}
        try:
            response = requests.post(url=api_url, json=body)
            response_json_dict = json.loads(response.text)
        except Exception as e:
            print("scrapy from api '%s' error!" % api_url, str(e))
            exit(1)
        return response_json_dict

    def scrapySA(self):
        """
        :API: https://gitee.com/openeuler/website-v2/blob/master/web-ui/docs/.vuepress/api/security.js
        :return: json
{
    "code": 0,
    "msg": "",
    "result": {
        "totalCount": 1425,
        "securityNoticeList": [
            {
                "id": 2773,
                "affectedComponent": "rubygem-activerecord",
                "affectedProduct": "openEuler-22.03-LTS-SP1",
                "announcementTime": "2023-03-01",
                "cveId": "CVE-2022-44566;CVE-2023-22794;",
                "description": "",
                "introduction": "",
                "packageName": "",
                "referenceDocuments": "",
                "revisionHistory": "",
                "securityNoticeNo": "openEuler-SA-2023-1133",
                "subject": "",
                "summary": "rubygem-activerecord security update",
                "type": "High",
                "updateTime": "2023-03-01 19:38:25",
                "cvrf": null,
                "packageHelperList": [],
                "packageList": [],
                "referenceList": [],
                "cveList": []
            },
            {},
            ...,
            {}
        ]
    }
}
        """

        api_url = 'https://www.openeuler.org/api-euler/api-cve/cve-security-notice-server/securitynotice/findAll'
        body = {"keyword": "", "yesr": "", "type": "", "pages": {"page": 1, "size": 1000000}}
        try:
            response = requests.post(url=api_url, json=body)
            response_json_dict = json.loads(response.text)
        except Exception as e:
            print("scrapy from api '%s' error!" % api_url, str(e))
            exit(1)
        return response_json_dict

    def scrapyCVRF_index(self):
        """
        :API: https://repo.openeuler.org/security/data/cvrf/index.txt
        :return: json
        """
        api_url = 'https://repo.openeuler.org/security/data/cvrf/index.txt'
        try:
            response = requests.get(url=api_url)
        except Exception as e:
            print("scrapy from api '%s' error!" % api_url, str(e))
            exit(1)
        if response.status_code < 200 or response.status_code > 299:
            print("ret code no in [200,300)")
            exit(1)
        return response.text

    def scrapyPerCVRF(self, url):
        head = {'Connection': 'close'}
        try:
            response = requests.get(url=url, headers=head)
            # TODO setup try times
        except Exception as e:
            print("scrapy from api '%s' error!" % url, str(e))
            exit(1)
        if response.status_code < 200 or response.status_code > 299:
            print("ret code %d no in [200,300)" % response.status_code)
            exit(1)
        return response.text

    def scrapyCVRF(self):
        """
        :API: https://repo.openeuler.org/security/data/cvrf/index.txt
        :return: json
        """
        api_url_prefix = 'https://repo.openeuler.org/security/data/cvrf'
        index_txt = self.scrapyCVRF_index().split('\n')
        for no, index_raw in enumerate(index_txt):
            index = index_raw.strip()
            cvrf_download_url = os.path.join(api_url_prefix, index)
            # print(cvrf_download_url)
            yield index, no + 1, len(index_txt) - no - 1, self.scrapyPerCVRF(cvrf_download_url)
