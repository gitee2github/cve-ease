#!/usr/bin/python3

import base64
import datetime
import hashlib
import hmac
import json
import subprocess
import time
import urllib.parse
import requests
import os
import sqlite3

# for update notify
SECRET = ''
TOKEN = ''
OLDRECORD = ''
# for status notify
STATUS_SECRET = ''
STATUS_TOKEN = ''


def dingtalk(message):
    message = "Message from cve-ease: \n" + \
              "当前时间 %s" % datetime.datetime.now().strftime("%Y年%m月%d日%H时%M分%S秒") + "\n" \
              + message

    timestamp = str(round(time.time() * 1000))
    secret_enc = SECRET.encode('utf-8')
    string_to_sign = '{}\n{}'.format(timestamp, SECRET)
    string_to_sign_enc = string_to_sign.encode('utf-8')
    hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
    sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
    webhook = '{}&timestamp={}&sign={}'.format(
        TOKEN, timestamp, sign)
    headers = {'Content-Type': 'application/json'}
    data = {
        "msgtype": "text",
        "text": {
            "content": message,
        },
    }

    x = requests.post(url=webhook, data=json.dumps(data), headers=headers)
    if x.json()["errcode"] == 0:
        return True
    else:
        return False


def dingtalkTop10(message):
    global STATUS_SECRET, STATUS_TOKEN
    message = "Message from CTyunOS ease: \n" + \
              "当前时间 %s" % datetime.datetime.now().strftime("%Y年%m月%d日%H时%M分%S秒") + "\n" \
              + message

    timestamp = str(round(time.time() * 1000))
    secret_enc = STATUS_SECRET.encode('utf-8')
    string_to_sign = '{}\n{}'.format(timestamp, STATUS_SECRET)
    string_to_sign_enc = string_to_sign.encode('utf-8')
    hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
    sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
    webhook = '{}&timestamp={}&sign={}'.format(
        STATUS_TOKEN, timestamp, sign)
    headers = {'Content-Type': 'application/json'}
    data = {
        "msgtype": "text",
        "text": {
            "content": message,
        },
    }

    x = requests.post(url=webhook, data=json.dumps(data), headers=headers)
    if x.json()["errcode"] == 0:
        return True
    else:
        return False


def runcmd(command, timeout=60):
    ret = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding="utf-8",
                         timeout=timeout)
    if ret.returncode == 0:
        return (0, ret)
    else:
        return (1, ret)


def log(logstr):
    logfilefullpath = "/var/log/ease/log"
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(logfilefullpath, "a+") as logfile:
        logsize = os.path.getsize(logfilefullpath)
        if logsize > 1024 * 1024 * 10:
            logfile.seek(0)
            logfile.truncate()
            logfile.write(" %s : truncate file \n" % (timestamp))
        logfile.write(" %s : %s \n" % (timestamp, logstr))


def is_between_time(begin_time, end_time):
    # "22:00:00", "8:00:00"
    now = time.strftime('%H:%M:%S')
    # 若是在 "8:00:00" - "22:00:00"
    if end_time < now < begin_time:
        return False
    else:
        return True


def do_update():
    result = "BAD"
    try:
        (retcode, result) = runcmd("/usr/bin/ease-cve -u", timeout=300)
        if retcode == 0:
            result = "OK"
        else:
            result = "BAD! " + str(result.stderr)
    except Exception as e:
        result = "BAD! " + str(e)
    return "%s" % result


def do_getTotal():
    try:
        conn = sqlite3.connect(DBFILE)
        cursor = conn.cursor()
        sql = """select count(*) from OpenEulerCVE;"""
        cursor.execute(sql)
        Tables = cursor.fetchall()
        conn.close()
        return str(Tables[0][0])
    except Exception as e:
        return str(e)


def do_readTop10():
    msg = ""
    try:
        conn = sqlite3.connect(DBFILE)
        cursor = conn.cursor()

        sql = """select * from OpenEulerCVE order by id desc limit 10;"""
        cursor.execute(sql)

        cdset = cursor.fetchall()
        cdset = [list(line) for line in cdset]  # 将结果集的元组转为列表，才能修改
        # msg += str(cdset)

        for record in cdset:
            msg += "评分:[%s] %s \n\t包名:%s" % (str(record[13]), record[11], record[31]) + "\n" + "  发布时间:%s" % record[
                28] + "\n"

        conn.close()
    except Exception as e:
        return str(e)

    return msg


def main():
    global OLDRECORD
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # 夜间22点-第二天早上8点，期间暂停更新，08 不可写为8,
    if (is_between_time("22:00:00", "08:00:00")):
        log("sleep time between 22:00:00 ~ 08:00:00")
        return

    data += "更新状态: %s" % do_update().strip() + "\n"
    data += "记录总数: %s" % do_getTotal().strip() + "\n"
    data += "Top10记录:\n"
    data += do_readTop10().strip()

    dingtalkTop10(data)

    if OLDRECORD == "":
        OLDRECORD = result.stdout
        dingtalk(data)
        return
    if OLDRECORD != result.stdout:
        dingtalk(data)
        OLDRECORD = result.stdout
        return




if __name__ == "__main__":
    if '' == SECRET or '' == TOKEN:
        log("No dingding TOKEN/SECRET found!")
        exit(1)

    if '' == STATUS_SECRET or '' == STATUS_TOKEN:
        log("No dingding STATUS_TOKEN/STATUS_SECRET found!")
        exit(1)

    try:
        main()
    except Exception as e:
        log("Error : %s" % str(e))
