package main

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"math"
	"net/http"
	"os"
	"strconv"
	"strings"
)

func respBodyToString(data []byte) string {
	var str bytes.Buffer
	_ = json.Indent(&str, []byte(data), "", "    ")
	//fmt.Println("formated: ", str.String())
	return str.String()
}

func respBodyToMap(data []byte) map[string]interface{} {
	var tempMap map[string]interface{}
	err := json.Unmarshal([]byte(data), &tempMap)
	if err != nil {
		panic(err)
	}
	//fmt.Println(tempMap)
	return tempMap
}

func getTotal(url, requestJson string) (total float64, err error) {
	var jsonStr = []byte(requestJson)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	//dataStr := respBodyToString(body)
	//fmt.Println(dataStr)

	dataMap := respBodyToMap(body)
	//fmt.Println(dataMap)
	if value, ok := dataMap["result"].(map[string]interface{})["totalCount"]; ok {
		//fmt.Println("total:", value)
		return value.(float64), nil
	}
	return -1, errors.New("Get total failed!")
}

func getCVE(url, requestJson string) []interface{} {
	var jsonStr = []byte(requestJson)
	//fmt.Println("jsonStr", jsonStr)
	//fmt.Println("new_str", bytes.NewBuffer(jsonStr))

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	// req.Header.Set("X-Custom-Header", "myvalue")
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	//fmt.Println("status", resp.Status)
	//fmt.Println("response:", resp.Header)
	body, _ := ioutil.ReadAll(resp.Body)

	//dataStr := respBodyToString(body)
	//fmt.Println(dataStr)

	dataMap := respBodyToMap(body)
	//fmt.Println(dataMap)
	dataArray := getArray(dataMap)
	//fmt.Println(dataArray)
	return dataArray
}

func getArray(dataMap map[string]interface{}) []interface{} {
	if result, ok := dataMap["result"]; ok {
		if cveDatabaseList, ok := result.(map[string]interface{})["cveDatabaseList"]; ok {
			return cveDatabaseList.([]interface{})
		}
	}
	return nil
}

func parseItem(item interface{}) {
	//fmt.Println(item)
	if mapData, ok := item.(map[string]interface{}); ok {
		//fmt.Println(mapData)
		if segment, ok := mapData["cveId"]; ok {
			fmt.Println("cveId :", segment)
		}
		if segment, ok := mapData["summary"]; ok {
			fmt.Println("summary :", segment)
		}
		if segment, ok := mapData["cvsssCoreNVD"]; ok {
			fmt.Println("cvsssCoreNVD :", segment)
		}
		if segment, ok := mapData["announcementTime"]; ok {
			fmt.Println("announcementTime :", segment)
		}
		if segment, ok := mapData["updateTime"]; ok {
			fmt.Println("updateTime :", segment)
		}
		if segment, ok := mapData["status"]; ok {
			fmt.Println("status :", segment)
		}
		if segment, ok := mapData["id"]; ok {
			fmt.Println("id :", segment)
		}
		//str,err := json.Marshal(mapData)
		//if err!= nil {
		//    panic("to json failed!")
		//}
		//fmt.Println(string(str))
	}
}

//定义OpenEulerCVE模型，绑定users表，ORM库操作数据库，需要定义一个struct类型和MYSQL表进行绑定或者叫映射，struct字段和MYSQL表字段一一对应
//在这里OpenEulerCVE类型可以代表mysql users表
//通过在字段后面的标签说明，定义golang字段和表字段的关系
//例如 `gorm:"column:username"` 标签说明含义是: Mysql表的列名（字段名)为username
//这里golang定义的OpenEulerCVEname变量和MYSQL表字段username一样，他们的名字可以不一样。
type OpenEulerCVE struct {
	ID                           int64   `json:"id"`
	AFFECTEDPRODUCT              string  `json:"affectedProduct"`
	ANNOUNCEMENTTIME             string  `json:"announcementTime"`
	ATTACKCOMPLEXITYNVD          string  `json:"attackComplexityNVD"`
	ATTACKCOMPLEXITYOE           string  `json:"attackComplexityOE"`
	ATTACKVECTORNVD              string  `json:"attackVectorNVD"`
	ATTACKVECTOROE               string  `json:"attackVectorOE"`
	AVAILABILITYNVD              string  `json:"availabilityNVD"`
	AVAILABILITYOE               string  `json:"availabilityOE"`
	CONFIDENTIALITYNVD           string  `json:"confidentialityNVD"`
	CONFIDENTIALITYOE            string  `json:"confidentialityOE"`
	CVEID                        string  `json:"cveId"`
	CVRF                         string  `json:"cvrf"`
	CVSSSCORENVD                 float64 `json:"cvsssCoreNVD"`
	CVSSSCOREOE                  float64 `json:"cvsssCoreOE"`
	INTEGRITYNVD                 string  `json:"integrityNVD"`
	INTEGRITYOE                  string  `json:"integrityOE"`
	NATIONALCYBERAWARENESSSYSTEM string  `json:"nationalCyberAwarenessSystem"`
	PACKAGELIST                  string  `json:"packageList"`
	PARSERBEAN                   string  `json:"parserBean"`
	PRIVILEGESREQUIREDNVD        string  `json:"privilegesRequiredNVD"`
	PRIVILEGESREQUIREDOE         string  `json:"privilegesRequiredOE"`
	SCOPENVD                     string  `json:"scopeNVD"`
	SCOPEOE                      string  `json:"scopeOE"`
	SECURITYNOTICENO             string  `json:"securityNoticeNo"`
	STATUS                       string  `json:"status"`
	SUMMARY                      string  `json:"summary"`
	TYPE                         string  `json:"type"`
	UPDATETIME                   string  `json:"updateTime"`
	USERINTERACTIONNVD           string  `json:"userInteractionNVD"`
	USERINTERACTIONOE            string  `json:"userInteractionOE"`
	PACKAGENAME                  string  `json:"packageName"`
}

//设置表名，可以通过给struct类型定义 TableName函数，返回当前struct绑定的mysql表名是什么
func (o OpenEulerCVE) TableName() string {
	//绑定MYSQL表名为users
	return "OpenEulerCVE"
}

//设置表名，可以通过给struct类型定义 TableName函数，返回当前struct绑定的mysql表名是什么
func (o OpenEulerCVE) ToStringSlice() []string {
	//绑定MYSQL表名为users
	// fmt.Printf("%#v\n",o.CVSSSCORENVD)
	return []string{
		strconv.FormatInt(o.ID, 10),
		o.CVEID,
		o.SUMMARY,
		o.PACKAGENAME,
		strconv.FormatFloat(o.CVSSSCORENVD, 'f', -1, 64),
		o.ANNOUNCEMENTTIME,
		o.UPDATETIME,
		o.STATUS,
	}
}

//设置表名，可以通过给struct类型定义 TableName函数，返回当前struct绑定的mysql表名是什么
func CSVToString(item []string) string {
	//绑定MYSQL表名为users
	// fmt.Printf("%#v\n",o.CVSSSCORENVD)
	return fmt.Sprintf(
		`ID: %s
CVEID: %s
SUMMARY: %s
PACKAGENAME: %s
CVSSSCORENVD: %s
ANNOUNCEMENTTIME: %s
UPDATETIME: %s
STATUS: %s
				`,
		item[0],
		item[1],
		item[2],
		item[3],
		item[4],
		item[5],
		item[6],
		item[7],
	)

}

func main() {
	// 参数处理
	var updateFlag bool
	var listFlag bool
	var outputDir string
	var searchStr string
	var reverseFlag bool
	var showNumber int

	flag.IntVar(&showNumber, "n", 0, "output the last NUM lines")
	flag.BoolVar(&reverseFlag, "r", false, "reverse output")
	flag.BoolVar(&updateFlag, "u", false, "update metadata")
	flag.StringVar(&outputDir, "o", "/usr/share/ctyunostools", "specific metadata path")
	flag.StringVar(&searchStr, "s", "", "search info")
	flag.BoolVar(&listFlag, "l", false, "list CVE info")
	flag.Parse()
	// fmt.Println(updateFlag)
	// fmt.Println(outputDir)
	// os.Exit(0)

	// 更新csv优先执行，不会考虑其他参数
	if true == updateFlag {
		url := "https://www.openeuler.org/api-cve/cve-security-notice-server/cvedatabase/findAll"
		page := 1
		size := 1
		data := make([]interface{}, 0)
		//data := make(map[string]interface{})

		fmt.Println("url: ", url)
		// {"keyword":"","status":"","pages":{"page":1,"size":100}}
		post := fmt.Sprintf(`{"keyword":"","status":"","pages":{"page":%d,"size":%d}}`, page, size)
		total, err := getTotal(url, post)
		if err != nil {
			fmt.Println("get total failed!", err)
		}
		fmt.Println("total:", total)

		size = 100
		//json序列化
		// {"keyword":"","status":"","pages":{"page":1,"size":100}}
		for ; float64(page) < math.Ceil(float64(total)/float64(size))+1; page += 1 {
			post = fmt.Sprintf(`{"keyword":"","status":"","pages":{"page":%d,"size":%d}}`, page, size)
			//fmt.Println(url, "post", post)
			data = append(data, getCVE(url, post)...)
			fmt.Println("scrapy from OpenEuler : ", len(data))
		}
		//fmt.Println(data)
		// fmt.Println("scrapy from OpenEuler :", len(data))
		//for index, item := range data {
		//    fmt.Println(index)
		//    parseItem(item)
		//}

		file, err := os.OpenFile(outputDir+"/cvelist.csv", os.O_CREATE|os.O_RDWR, 0644)
		if err != nil {
			fmt.Println("open file is failed, err: ", err)
		}
		defer file.Close()
		// 写入UTF-8 BOM，防止中文乱码
		// file.WriteString("\xEF\xBB\xBF")
		w := csv.NewWriter(file)
		// 写csv头部
		// w.Write([]string{
		// 	"ID",
		// 	"CVEID",
		// 	"SUMMARY",
		// 	"CVSSSCORENVD",
		// 	"ANNOUNCEMENTTIME",
		// 	"UPDATETIME",
		// 	"STATUS",
		// })

		for _, item := range data {
			//fmt.Println(index)
			//定义一个用户，并初始化数据
			o := OpenEulerCVE{}
			//{
			//    ID:               int64(mapData["id"].(float64)),
			//    CVEID:            mapData["cveID"].(string),
			//    SUMMARY:          mapData["summary"].(string),
			//    CVSSSCORENVD:     mapData["cvsssCoreNVD"].(float64),
			//    ANNOUNCEMENTTIME: mapData["announcementTime"].(int64),
			//    UPDATETIME:       mapData["updateTime"].(int64),
			//    STATUS:           mapData["status"].(string),
			//}
			if mapData, ok := item.(map[string]interface{}); ok {
				//fmt.Println(mapData)

				if segment, ok := mapData["id"]; ok {
					// fmt.Println("id :", segment)
					// fmt.Printf("%T\n", segment)
					o.ID = int64(segment.(float64))
				}
				if segment, ok := mapData["cveId"]; ok {
					// fmt.Println("cveId :", segment)
					o.CVEID = segment.(string)
				}
				if segment, ok := mapData["summary"]; ok {
					// fmt.Println("summary :", segment)
					o.SUMMARY = segment.(string)
				}
				if segment, ok := mapData["cvsssCoreNVD"]; ok {
					// fmt.Println("cvsssCoreNVD :", segment)
					o.CVSSSCORENVD, _ = strconv.ParseFloat(segment.(string), 64)
				}
				if segment, ok := mapData["announcementTime"]; ok {
					// fmt.Println("+announcementTime :", segment)
					o.ANNOUNCEMENTTIME, _ = segment.(string)
				}
				if segment, ok := mapData["updateTime"]; ok {
					// fmt.Println("+updateTime :", segment)
					o.UPDATETIME, _ = segment.(string)
				}
				if segment, ok := mapData["status"]; ok {
					// fmt.Println("status :", segment)
					o.STATUS = segment.(string)
				}
				if segment, ok := mapData["packageName"]; ok {
					// fmt.Println("packageName :", segment)
					o.PACKAGENAME = segment.(string)
				}
				//写入数据
				w.Write(o.ToStringSlice())
				// 写文件需要flush，不然缓存满了，后面的就写不进去了，只会写一部分
				w.Flush()
			}
		}
		fmt.Println("All done!")
		return
	}

	// 是否罗列数据
	if true == listFlag {
		file, err := os.Open(outputDir + "/cvelist.csv")
		if err != nil {
			fmt.Println("open file is failed, err: ", err)
			fmt.Println("Please run 'plm cve -u' to generate metadata")
			os.Exit(1)
		}
		defer file.Close()

		//创建csv读取接口实例
		ReadCsv := csv.NewReader(file)
		//读取所有内容
		ReadAll, err := ReadCsv.ReadAll()

		dataToShow := len(ReadAll)
		if 0 > showNumber {
			return
		}
		if showNumber < len(ReadAll) && showNumber > 0 {
			dataToShow = showNumber
		}
		// fmt.Println(dataToShow)

		//fmt.Println(ReadAll)
		if true == reverseFlag {
			// 反向显示，ID小的先显示
			for i := len(ReadAll) - 1; i > len(ReadAll)-showNumber-1; i-- {
				item := ReadAll[i]
				fmt.Println(CSVToString(item))
			}
		} else {
			// 正向显示，ID大的先显示
			for _, item := range ReadAll[:dataToShow] {
				fmt.Println(CSVToString(item))
			}
		}
		return
	}

	// 是否检索数据
	if "" != searchStr {
		file, err := os.Open(outputDir + "/cvelist.csv")
		if err != nil {
			fmt.Println("open file is failed, err: ", err)
			fmt.Println("Please run  'plm cve -u' to generate metadata")
			return
		}
		defer file.Close()

		//创建csv读取接口实例
		ReadCsv := csv.NewReader(file)

		//读取所有内容
		ReadAll, err := ReadCsv.ReadAll()
		//fmt.Println(ReadAll)
		// for i := len(ReadAll) - 1; i > 0; i-- {
		// 	item := ReadAll[i]
		showFlag := false
		for _, item := range ReadAll {
			for _, str := range item {
				// 是否要实现大小写无关，后续安排
				if strings.Contains(str, searchStr) {
					showFlag = true
				}
			}
			if showFlag == false {
				continue
			}
			fmt.Println(CSVToString(item))
			showFlag = false
		}
		return
	}
	flag.PrintDefaults()
}
